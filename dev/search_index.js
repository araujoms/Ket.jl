var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Ket]","category":"page"},{"location":"api/#Ket._fiducial_WH-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"API reference","title":"Ket._fiducial_WH","text":"_fiducial_WH(d::Integer)\n\nComputes the fiducial Weyl-Heisenberg vector of dimension d.\n\nReference: Appleby, Yadsan-Appleby, Zauner, arXiv:1209.1813 http://www.gerhardzauner.at/sicfiducials.html\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket._partition-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"API reference","title":"Ket._partition","text":"partition(n::Integer, k::Integer)\n\nIf n ≥ k partitions the set 1:n into k parts as equally sized as possible. Otherwise partitions it into n parts of size 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.anti_isotropic-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Real}, Tuple{Type{T}, Real, Integer}} where T<:Number","page":"API reference","title":"Ket.anti_isotropic","text":"Produces the anti-isotropic state of local dimension d with visibility v\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.binary_entropy-Tuple{Real, Real}","page":"API reference","title":"Ket.binary_entropy","text":"binary_entropy([b=2,] p::Real)\n\nComputes the Shannon entropy -p log(p) - (1-p)log(1-p) of a probability p using a base b logarithm.\n\nReference: Entropy (information theory).\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.binary_relative_entropy-Tuple{Real, Real, Real}","page":"API reference","title":"Ket.binary_relative_entropy","text":"binary_relative_entropy([b=2,] p::Real, q::Real)\n\nComputes the binary relative entropy D(p||q) = p log(p/q) + (1-p) log((1-p)/(1-q)) between two probabilities p and q using a base b logarithm.\n\nReference: Relative entropy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.cglmp-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"API reference","title":"Ket.cglmp","text":"cglmp([T=Float64,] d::Integer)\n\nCGLMP nonlocal game in full probability notation. If T is an integer type the game is unnormalized.\n\nReferences: arXiv:quant-ph/0106024 for the original game, and arXiv:2005.13418 for the form presented here.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.chsh-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"API reference","title":"Ket.chsh","text":"chsh([T=Float64,] d::Integer = 2)\n\nCHSH-d nonlocal game in full probability notation. If T is an integer type the game is unnormalized.\n\nReference: Buhrman and Massar, arXiv:quant-ph/0409066.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.cleanup!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:Number","page":"API reference","title":"Ket.cleanup!","text":"cleanup!(M::AbstractArray{T}; tol = Base.rtoldefault(real(T)))\n\nZeroes out real or imaginary parts of M that are smaller than tol.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.clock-Union{Tuple{T}, Tuple{Type{T}, Integer}, Tuple{Type{T}, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.clock","text":"clock([T=ComplexF64,] d::Integer, p::Integer = 1)\n\nConstructs the clock operator Z of dimension d to the power p.\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.correlation_tensor-Union{Tuple{AbstractArray{T, N2}}, Tuple{T}, Tuple{N2}} where {N2, T<:Number}","page":"API reference","title":"Ket.correlation_tensor","text":"correlation_tensor(p::AbstractArray{T, N2}; marg::Bool = true)\n\nApplies N sets of POVMs onto a state rho to form a probability array. Convert a 2x...x2xmx...xm probability array into\n\na mx...xm correlation array (no marginals)\na (m+1)x...x(m+1) correlation array (marginals).\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.dilate_povm-Tuple{Vector{<:AbstractMatrix}}","page":"API reference","title":"Ket.dilate_povm","text":"dilate_povm(E::Vector{<:AbstractMatrix})\n\nDoes the Naimark dilation of a POVM given as a vector of matrices. This always works, but is wasteful if the POVM elements are not full rank.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.dilate_povm-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Union{Real, Complex}","page":"API reference","title":"Ket.dilate_povm","text":"dilate_povm(vecs::Vector{Vector{T}})\n\nDoes the Naimark dilation of a rank-1 POVM given as a vector of vectors. This is the minimal dilation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.entropy-Tuple{Real, AbstractMatrix}","page":"API reference","title":"Ket.entropy","text":"entropy([b=2,] ρ::AbstractMatrix)\n\nComputes the von Neumann entropy -tr(ρ log ρ) of a positive semidefinite operator ρ using a base b logarithm.\n\nReference: von Neumann entropy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.entropy-Tuple{Real, AbstractVector}","page":"API reference","title":"Ket.entropy","text":"entropy([b=2,] p::AbstractVector)\n\nComputes the Shannon entropy -Σᵢpᵢlog(pᵢ) of a non-negative vector p using a base b logarithm.\n\nReference: Entropy (information theory).\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.fp2cg-Union{Tuple{AbstractArray{T, 4}}, Tuple{T}} where T<:Real","page":"API reference","title":"Ket.fp2cg","text":"fp2cg(V::Array{T,4}) where {T <: Real}\n\nTakes a bipartite Bell functional V in full probability notation and transforms it to Collins-Gisin notation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.gell_mann!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer}, Tuple{AbstractMatrix{T}, Integer, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.gell_mann!","text":"gell_mann!(res::AbstractMatrix{T}, i::Integer, j::Integer, d::Integer = 3)\n\nIn-place version of gell_mann.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.gell_mann-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"API reference","title":"Ket.gell_mann","text":"gell_mann([T=ComplexF64,], d::Integer = 3)\n\nConstructs the set G of generalized Gell-Mann matrices in dimension d such that G[1] = I and G[i]*G[j] = 2 δ_ij.\n\nReference: Generalizations of Pauli matrices\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.gell_mann-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}, Tuple{Type{T}, Integer, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.gell_mann","text":"gell_mann([T=ComplexF64,], i::Integer, j::Integer, d::Integer = 3)\n\nConstructs the set i,jth Gell-Mann matrix of dimension d.\n\nReference: Generalizations of Pauli matrices\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.isotropic-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Real}, Tuple{Type{T}, Real, Integer}} where T<:Number","page":"API reference","title":"Ket.isotropic","text":"Produces the isotropic state of local dimension d with visibility v\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.ket-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.ket","text":"ket([T=ComplexF64,] i::Integer, d::Integer)\n\nProduces a ket of dimension d with nonzero element i.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.ketbra-Tuple{AbstractVector}","page":"API reference","title":"Ket.ketbra","text":"ketbra(v::AbstractVector)\n\nProduces a ketbra of vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.kyfan_norm","page":"API reference","title":"Ket.kyfan_norm","text":"kyfan_norm(X::AbstractMatrix, k::Int, p::Real = 2)\n\nComputes Ky-Fan (k,p) norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.local_bound-Union{Tuple{Array{T, 4}}, Tuple{T}} where T<:Real","page":"API reference","title":"Ket.local_bound","text":"local_bound(G::Array{T,4})\n\nComputes the local bound of a bipartite Bell functional G, written in full probability notation as a 4-dimensional array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.mub-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"API reference","title":"Ket.mub","text":"mub(d::Integer)\n\nConstruction of the standard complete set of MUBs. The output contains 1+minᵢ pᵢ^rᵢ bases, where d = ∏ᵢ pᵢ^rᵢ.\n\nReference: Durt, Englert, Bengtsson, Życzkowski, arXiv:1004.3348.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.phiplus-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"API reference","title":"Ket.phiplus","text":"Produces the maximally entangled state Φ⁺ of local dimension d\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.povm-Union{Tuple{Array{T, 4}}, Tuple{T}, Tuple{Array{T, 4}, Vector{Int64}}} where T<:Number","page":"API reference","title":"Ket.povm","text":"povm(A::Array{T, 4}, n::Vector{Int64})\n\nConverts a set of POVMs in the common tensor format into a matrix of matrices. The second argument is fixed by the size of A but can also contain custom number of outcomes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.povm-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"API reference","title":"Ket.povm","text":"povm(B::Vector{<:AbstractMatrix{T}})\n\nCreates a set of (projective) POVMs from a set of bases given as unitary matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.probability_tensor-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{LinearAlgebra.Hermitian{T1, Matrix{T1}}, Vararg{Array{Array{LinearAlgebra.Hermitian{T2, Matrix{T2}}, 1}, 1}, N}}} where {T1<:Number, T2<:Number, N}","page":"API reference","title":"Ket.probability_tensor","text":"probability_tensor(Aax::Vector{POVM{T}})\n\nApplies N sets of POVMs onto a state rho to form a probability array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.proj-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.proj","text":"proj([T=ComplexF64,] i::Integer, d::Integer)\n\nProduces a projector onto the basis state i in dimension d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.psiminus-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"API reference","title":"Ket.psiminus","text":"Produces the maximally entangled state ψ⁻ of local dimension d\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.random_povm-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}, Tuple{Type{T}, Integer, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.random_povm","text":"random_povm([T=ComplexF64,] d::Integer, n::Integer, r::Integer)\n\nProduces a random POVM of dimension d with n outcomes and rank min(k, d).\n\nReference: Heinosaari et al., arXiv:1902.04751.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.random_probability-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"API reference","title":"Ket.random_probability","text":"random_probability([T=Float64,] d::Integer)\n\nProduces a random probability vector of dimension d uniformly distributed on the simplex.\n\nReference: Dirichlet distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.random_state-Union{Tuple{T}, Tuple{Type{T}, Integer}, Tuple{Type{T}, Integer, Integer}} where T","page":"API reference","title":"Ket.random_state","text":"random_state([T=ComplexF64,] d::Integer, k::Integer = d)\n\nProduces a uniformly distributed random quantum state in dimension d with rank k.\n\nReference: Życzkowski and Sommers, arXiv:quant-ph/0012101.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.random_state_vector-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"API reference","title":"Ket.random_state_vector","text":"random_state_vector([T=ComplexF64,] d::Integer)\n\nProduces a Haar-random quantum state vector in dimension d.\n\nReference: Życzkowski and Sommers, arXiv:quant-ph/0012101.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.random_unitary-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:Number","page":"API reference","title":"Ket.random_unitary","text":"random_unitary([T=ComplexF64,] d::Integer)\n\nProduces a Haar-random unitary matrix in dimension d. If T is a real type the output is instead a Haar-random (real) orthogonal matrix.\n\nReference: Mezzadri, arXiv:math-ph/0609050.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.relative_entropy-Union{Tuple{S}, Tuple{T}, Tuple{Real, AbstractMatrix{T}, AbstractMatrix{S}}} where {T, S<:Number}","page":"API reference","title":"Ket.relative_entropy","text":"relative_entropy([b=2,] ρ::AbstractMatrix, σ::AbstractMatrix)\n\nComputes the (quantum) relative entropy tr(ρ (log ρ - log σ)) between positive semidefinite matrices ρ and σ using a base b logarithm. Note that the support of ρ must be contained in the support of σ but for efficiency this is not checked.\n\nReference: Quantum relative entropy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.relative_entropy-Union{Tuple{S}, Tuple{T}, Tuple{Real, AbstractVector{T}, AbstractVector{S}}} where {T, S<:Real}","page":"API reference","title":"Ket.relative_entropy","text":"relative_entropy([b=2,] p::AbstractVector, q::AbstractVector)\n\nComputes the relative entropy D(p||q) = Σᵢpᵢlog(pᵢ/qᵢ) between two non-negative vectors p and q using a base b logarithm. Note that the support of p must be contained in the support of q but for efficiency this is not checked.\n\nReference: Relative entropy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.schatten_norm-Tuple{AbstractMatrix, Real}","page":"API reference","title":"Ket.schatten_norm","text":"schatten_norm(X::AbstractMatrix, p::Real)\n\nComputes Schatten p-norm of matrix X.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.shift-Union{Tuple{T}, Tuple{Type{T}, Integer}, Tuple{Type{T}, Integer, Integer}} where T<:Number","page":"API reference","title":"Ket.shift","text":"shift([T=ComplexF64,] d::Integer, p::Integer = 1)\n\nConstructs the shift operator X of dimension d to the power p.\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.sic_povm-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T","page":"API reference","title":"Ket.sic_povm","text":"sic_povm(d::Integer)\n\nConstructs a vector of d² vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension d. This construction is based on the Weyl-Heisenberg fiducial.\n\nReference: Appleby, Yadsan-Appleby, Zauner, arXiv:1209.1813\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.test_mub-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Number","page":"API reference","title":"Ket.test_mub","text":"Check whether the input is indeed mutually unbiased\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.test_sic-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Number","page":"API reference","title":"Ket.test_sic","text":"test_sic(vecs)\n\nTests whether vecs is a vector of d² vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.trace_norm-Tuple{AbstractMatrix}","page":"API reference","title":"Ket.trace_norm","text":"trace_norm(X::AbstractMatrix)\n\nComputes trace norm of matrix X. \n\n\n\n\n\n","category":"method"},{"location":"api/#Ket.tsirelson_bound-Tuple{Matrix{<:Real}, Vector{<:Integer}, Integer}","page":"API reference","title":"Ket.tsirelson_bound","text":"tsirelson_bound(CG::Matrix, scenario::Vector, level::Integer)\n\nUpper bounds the Tsirelson bound of a bipartite Bell funcional game CG, written in Collins-Gisin notation. scenario is vector detailing the number of inputs and outputs, in the order [oa, ob, ia, ib]. level is an integer determining the level of the NPA hierarchy.\n\nThis function requires Moment. It is only available if you first do \"import MATLAB\" or \"using MATLAB\".\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/araujoms/Ket.jl/blob/master/README.md\"","category":"page"},{"location":"#Ket.jl","page":"Home","title":"Ket.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Toolbox for quantum information, nonlocality, and entanglement","category":"page"}]
}
