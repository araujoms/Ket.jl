var documenterSearchIndex = {"docs":
[{"location":"api/#List-of-functions","page":"List of functions","title":"List of functions","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"Ket","category":"page"},{"location":"api/#Ket","page":"List of functions","title":"Ket","text":"Toolbox for quantum information, nonlocality, and entanglement.\n\n\n\n\n\n","category":"module"},{"location":"api/#Basic","page":"List of functions","title":"Basic","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"ket\nketbra\nproj\nshift\nclock\nshiftclock\npauli\ngellmann\ngellmann!\npartial_trace\npartial_transpose\npermute_systems\ncleanup!\nsymmetric_projector\nsymmetric_isometry\northonormal_range\npermutation_matrix\nn_body_basis","category":"page"},{"location":"api/#Ket.ket","page":"List of functions","title":"Ket.ket","text":"ket([T=Bool,] i::Integer, d::Integer = 2)\n\nProduces a ket of dimension d with nonzero element i.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.ketbra","page":"List of functions","title":"Ket.ketbra","text":"ketbra(v::AbstractVector)\n\nProduces a ketbra of vector v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.proj","page":"List of functions","title":"Ket.proj","text":"proj([T=Bool,] i::Integer, d::Integer = 2)\n\nProduces a projector onto the basis state i in dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.shift","page":"List of functions","title":"Ket.shift","text":"shift([T=ComplexF64,] d::Integer, p::Integer = 1)\n\nConstructs the shift operator X of dimension d to the power p.\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.clock","page":"List of functions","title":"Ket.clock","text":"clock([T=ComplexF64,] d::Integer, q::Integer = 1)\n\nConstructs the clock operator Z of dimension d to the power q.\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.shiftclock","page":"List of functions","title":"Ket.shiftclock","text":"shiftclock(v::AbstractVector, p::Integer, q::Integer)\n\nProduces X^p * Z^q * v, where X and Z are the shift and clock operators of dimension length(v).\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.pauli","page":"List of functions","title":"Ket.pauli","text":"pauli([T=ComplexF64,], ind::Vector{<:Integer})\n\nConstructs the Pauli matrices: 0 or \"I\" for the identity, 1 or \"X\" for the Pauli X operation, 2 or \"Y\" for the Pauli Y operator, and 3 or \"Z\" for the Pauli Z operator. Vectors of integers between 0 and 3 or strings of I, X, Y, Z automatically generate Kronecker products of the corresponding operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.gellmann","page":"List of functions","title":"Ket.gellmann","text":"gellmann([T=ComplexF64,], d::Integer = 3)\n\nConstructs the set G of generalized Gell-Mann matrices in dimension d such that G₁ = I and Tr(GᵢGⱼ) = 2 δᵢⱼ.\n\nReference: Generalizations of Pauli matrices\n\n\n\n\n\ngellmann([T=ComplexF64,], i::Integer, j::Integer, d::Integer = 3)\n\nConstructs the set i,jth Gell-Mann matrix of dimension d.\n\nReference: Generalizations of Pauli matrices\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.gellmann!","page":"List of functions","title":"Ket.gellmann!","text":"gellmann!(res::AbstractMatrix{T}, i::Integer, j::Integer, d::Integer = 3)\n\nIn-place version of gellmann.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.partial_trace","page":"List of functions","title":"Ket.partial_trace","text":"partial_trace(X::AbstractMatrix, remove::AbstractVector, dims::AbstractVector = _equal_sizes(X))\n\nTakes the partial trace of matrix X with subsystem dimensions dims over the subsystems in remove. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\npartial_trace(X::AbstractMatrix, remove::Integer, dims::AbstractVector = _equal_sizes(X)))\n\nTakes the partial trace of matrix X with subsystem dimensions dims over the subsystem remove. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.partial_transpose","page":"List of functions","title":"Ket.partial_transpose","text":"partial_transpose(X::AbstractMatrix, transp::AbstractVector, dims::AbstractVector = _equal_sizes(X))\n\nTakes the partial transpose of matrix X with subsystem dimensions dims on the subsystems in transp. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\npartial_transpose(X::AbstractMatrix, transp::Integer, dims::AbstractVector = _equal_sizes(X))\n\nTakes the partial transpose of matrix X with subsystem dimensions dims on the subsystem transp. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.permute_systems","page":"List of functions","title":"Ket.permute_systems","text":"permute_systems(X::AbstractVector, perm::AbstractVector, dims::AbstractVector = _equal_sizes(X))\n\nPermutes the order of the subsystems of vector X with subsystem dimensions dims according to the permutation perm. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\npermute_systems(X::AbstractMatrix, perm::AbstractVector, dims::AbstractVector = _equal_sizes(X))\n\nPermutes the order of the subsystems of the square matrix X, which is composed by square subsystems of dimensions dims, according to the permutation perm. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\npermute_systems(X::AbstractMatrix, perm::Vector, dims::Matrix)\n\nPermutes the order of the subsystems of the matrix X, which is composed by subsystems of dimensions dims, according to the permutation perm. dims should be a n × 2 matrix where dims[i, 1] is the number of rows of subsystem i, and dims[i, 2] is its number of columns.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.cleanup!","page":"List of functions","title":"Ket.cleanup!","text":"cleanup!(M::AbstractArray{T}; tol = Base.rtoldefault(real(T)))\n\nZeroes out real or imaginary parts of M that are smaller than tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.symmetric_projector","page":"List of functions","title":"Ket.symmetric_projector","text":"symmetric_projector(dim::Integer, n::Integer)\n\nComputes the projector onto the symmetric subspace of n copies of a dim-dimensional space.\n\nReference: Watrous' book, Sec. 7.1.1\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.symmetric_isometry","page":"List of functions","title":"Ket.symmetric_isometry","text":"symmetric_isometry(dim::Integer, n::Integer)\n\nComputes an isometry that encodes the symmetric subspace of n copies of a dim-dimensional space. Specifically, it maps a vector space of dimension binomial(n + dim -1, dim -1) onto the symmetric subspace of the symmetric subspace of the vector space of dimension dim^n.\n\nReference: Watrous' book, Sec. 7.1.1\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.orthonormal_range","page":"List of functions","title":"Ket.orthonormal_range","text":"orthonormal_range(A::AbstractMatrix{T}; tol::T=nothing) where {T<:Number}\n\nOrthonormal basis for the range of A. When A is sparse and T ∈ [Float64, ComplexF64, Float32, ComplexF32], uses a QR factorization and returns a sparse result, otherwise uses an SVD and returns a dense matrix. Tolerance tol is used to compute the rank and is automatically set if not provided.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.permutation_matrix","page":"List of functions","title":"Ket.permutation_matrix","text":"permutation_matrix(dims::Union{Integer,AbstractVector}, perm::AbstractVector)\n\nUnitary that permutes subsystems of dimension dims according to the permutation perm. If dims is an Integer, assumes there are length(perm) subsystems of equal dimensions dims.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.n_body_basis","page":"List of functions","title":"Ket.n_body_basis","text":"n_body_basis(\nn::Integer,\nn_parties::Integer;\nsb::AbstractVector{<:AbstractMatrix} = [pauli(1), pauli(2), pauli(3)],\neye::AbstractMatrix = I(size(sb[1], 1))\n\nReturn the basis of n nontrivial operators acting on n_parties, by default using sparse Pauli matrices.\n\nFor example, n_body_basis(2, 3) generates all products of two Paulis and one identity, so X  X  1 X  1  X  X  Y  1  1  Z  Z.\n\nInstead of Paulis, a basis can be provided by the parameter sb, and the identity can be changed with eye.\n\nThis function returns a generator, which can then be used e.g. in for loops without fully allocating the entire basis at once. If you need a vector, call collect on it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Channels","page":"List of functions","title":"Channels","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"applykraus\napplykraus!\nchoi\nchannel_bit_flip\nchannel_phase_damping\nchannel_phase_flip\nchannel_amplitude_damping\nchannel_amplitude_damping_generalized\nchannel_bit_phase_flip\nchannel_depolarizing","category":"page"},{"location":"api/#Ket.applykraus","page":"List of functions","title":"Ket.applykraus","text":"applykraus(K::Vector{<:AbstractMatrix}, M::AbstractMatrix)\n\nApplies the CP map given by the Kraus operators K to the matrix M.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.applykraus!","page":"List of functions","title":"Ket.applykraus!","text":"applykraus!(result::Matrix, K::Vector{<:AbstractMatrix}, M::AbstractMatrix, temp::Matrix)\n\nApplies the CP map given by the Kraus operators K to the matrix M without allocating. result and temp must be matrices of size dout × dout and dout × din, where dout, din == size(K[1]).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.choi","page":"List of functions","title":"Ket.choi","text":"choi(K::Vector{<:AbstractMatrix})\n\nConstructs the Choi-Jamiołkowski representation of the CP map given by the Kraus operators K. The convention used is that choi(K) = ∑ᵢⱼ |i⟩⟨j|⊗K|i⟩⟨j|K'\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_bit_flip","page":"List of functions","title":"Ket.channel_bit_flip","text":"channel_bit_flip(p::Real)\n\nReturn the Kraus operator representation of the bit flip channel. It applies Pauli-X with probability 1 − p (flip from |0⟩ to |1⟩ and vice versa).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_phase_damping","page":"List of functions","title":"Ket.channel_phase_damping","text":"channel_phase_damping(rho::AbstractMatrix, λ::Real)\n\nReturn the Kraus operator representation of the phase damping channel. It describes the photon scattering or electron perturbation. 'λ' is the probability being scattered or perturbed (without loss of energy).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_phase_flip","page":"List of functions","title":"Ket.channel_phase_flip","text":"channel_phase_flip(p::Real)\n\nReturn the Kraus operator representation of the phase flip channel. It applies Pauli-Z with probability 1 − p.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_amplitude_damping","page":"List of functions","title":"Ket.channel_amplitude_damping","text":"channel_amplitude_damping(rho::AbstractMatrix, γ::Real)\n\nReturn the Kraus operator representation of the amplitude damping channel. It describes the effect of dissipation to an environment at zero temperature. γ is the probability of the system to decay to the ground state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_amplitude_damping_generalized","page":"List of functions","title":"Ket.channel_amplitude_damping_generalized","text":"channel_amplitude_damping_generalized(rho::AbstractMatrix, p::Real, γ::Real)\n\nReturn the Kraus operator representation of the generalized amplitude damping channel. It describes the effect of dissipation to an environment at finite temperature. γ is the probability of the system to decay to the ground state. 1-p can be thought as the energy of the stationary state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_bit_phase_flip","page":"List of functions","title":"Ket.channel_bit_phase_flip","text":"channel_bit_phase_flip(p::Real)\n\nReturn the Kraus operator representation of the phase flip channel. It applies Pauli-Y (=iXY) with probability 1 − p.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_depolarizing","page":"List of functions","title":"Ket.channel_depolarizing","text":"channel_depolarizing(rho::AbstractMatrix, p::Real)\n\nReturn the Kraus operator representation of the depolarizing channel. It replaces a single qubit by the completely mixed state with probability 'p'.\n\n\n\n\n\n","category":"function"},{"location":"api/#Entanglement","page":"List of functions","title":"Entanglement","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"schmidt_decomposition\nentanglement_entropy\nentanglement_robustness\nschmidt_number\nppt_mixture","category":"page"},{"location":"api/#Ket.schmidt_decomposition","page":"List of functions","title":"Ket.schmidt_decomposition","text":"schmidt_decomposition(ψ::AbstractVector, dims::AbstractVecOrTuple = _equal_sizes(ψ))\n\nProduces the Schmidt decomposition of ψ with subsystem dimensions dims. If the argument dims is omitted equally-sized subsystems are assumed. Returns the (sorted) Schmidt coefficients λ and isometries U, V such that kron(U', V')*ψ is of Schmidt form.\n\nReference: Schmidt decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.entanglement_entropy","page":"List of functions","title":"Ket.entanglement_entropy","text":"entanglement_entropy(ψ::AbstractVector, dims::AbstractVecOrTuple = _equal_sizes(ψ))\n\nComputes the relative entropy of entanglement of a bipartite pure state ψ with subsystem dimensions dims. If the argument dims is omitted equally-sized subsystems are assumed.\n\n\n\n\n\nentanglement_entropy(ρ::AbstractMatrix, dims::AbstractVecOrTuple = _equal_sizes(ρ), n::Integer = 1; verbose = false)\n\nLower bounds the relative entropy of entanglement of a bipartite state ρ with subsystem dimensions dims using level n of the DPS hierarchy. If the argument dims is omitted equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.entanglement_robustness","page":"List of functions","title":"Ket.entanglement_robustness","text":"entanglement_robustness(\n    ρ::AbstractMatrix{T},\n    dims::AbstractVecOrTuple = _equal_sizes(ρ),\n    n::Integer = 1;\n    noise::String = \"white\"\n    ppt::Bool = true,\n    inner::Bool = false,\n    verbose::Bool = false,\n    dualize::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nLower (or upper) bounds the entanglement robustness of state ρ with subsystem dimensions dims using level n of the DPS hierarchy (or inner DPS, when inner = true). Argument noise indicates the kind of noise to be used: \"white\" (default), \"separable\", or \"general\". Argument ppt indicates whether to include the partial transposition constraints. Argument dualize determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.\n\nReturns the robustness and a witness W (note that for inner = true, this might not be a valid entanglement witness).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.schmidt_number","page":"List of functions","title":"Ket.schmidt_number","text":"schmidt_number(\n    ρ::AbstractMatrix{T},\n    s::Integer = 2,\n    dims::AbstractVecOrTuple = _equal_sizes(ρ),\n    n::Integer = 1;\n    ppt::Bool = true,\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nUpper bound on the white noise robustness of ρ such that it has a Schmidt number s.\n\nIf a state ρ with local dimensions d_A and d_B has Schmidt number s, then there is a PSD matrix ω in the extended space AABB, where A and B have dimension s, such that ω  s is separable  against AABB and Π^ ω Π = ρ, where Π = 1_A  s ψ^+  1_B, and ψ^+ is a non-normalized maximally entangled state. Separabiity is tested with the DPS hierarchy, with n controlling the how many copies of the BB subsystem are used.\n\nReferences:\n\nHulpke, Bruss, Lewenstein, Sanpera, arXiv:quant-ph/0401118\nWeilenmann, Dive, Trillo, Aguilar, Navascués, arXiv:1912.10056\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.ppt_mixture","page":"List of functions","title":"Ket.ppt_mixture","text":"function ppt_mixture(\n    ρ::AbstractMatrix{T},\n    dims::AbstractVecOrTuple;\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nLower bound on the white noise such that ρ is still a genuinely multipartite entangled state and a GME witness that detects ρ.\n\nThe set of GME states is approximated by the set of PPT mixtures, so the entanglement across the bipartitions is decided with the PPT criterion. If the state is a PPT mixture, returns a 0 matrix instead of a witness.\n\nReference: Jungnitsch, Moroder, Gühne, arXiv:quant-ph/0401118\n\n\n\n\n\nfunction ppt_mixture(\n    ρ::AbstractMatrix{T},\n    dims::AbstractVecOrTuple,\n    obs::AbstractVector{<:AbstractMatrix} = Vector{Matrix}();\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nLower bound on the white noise such that ρ is still a genuinely multipartite entangled state that can be detected with a witness using only the operators provided in obs, and the values of the coefficients defining such a witness.\n\nMore precisely, if a list of observables O_i is provided in the parameter obs, the witness will be of the form _i α_i O_i and detects ρ only using these observables. For example, using only two-body operators (and lower order) one can call\n\njulia> two_body_basis = collect(Iterators.flatten(n_body_basis(i, 3) for i ∈ 0:2))\njulia> ppt_mixture(state_ghz(2, 3), [2, 2, 2], two_body_basis)\n\nReference: Jungnitsch, Moroder, Gühne arXiv:quant-ph/0401118\n\n\n\n\n\n","category":"function"},{"location":"api/#Entropy","page":"List of functions","title":"Entropy","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"entropy\nbinary_entropy\nrelative_entropy\nbinary_relative_entropy\nconditional_entropy","category":"page"},{"location":"api/#Ket.entropy","page":"List of functions","title":"Ket.entropy","text":"entropy([base=2,] ρ::AbstractMatrix)\n\nComputes the von Neumann entropy -tr(ρ log ρ) of a positive semidefinite operator ρ using a base base logarithm.\n\nReference: von Neumann entropy\n\n\n\n\n\nentropy([base=2,] p::AbstractVector)\n\nComputes the Shannon entropy -Σᵢpᵢlog(pᵢ) of a non-negative vector p using a base base logarithm.\n\nReference: Entropy (information theory)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.binary_entropy","page":"List of functions","title":"Ket.binary_entropy","text":"binary_entropy([base=2,] p::Real)\n\nComputes the Shannon entropy -p log(p) - (1-p)log(1-p) of a probability p using a base base logarithm.\n\nReference: Entropy (information theory)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.relative_entropy","page":"List of functions","title":"Ket.relative_entropy","text":"relative_entropy([base=2,] ρ::AbstractMatrix, σ::AbstractMatrix)\n\nComputes the (quantum) relative entropy tr(ρ (log ρ - log σ)) between positive semidefinite matrices ρ and σ using a base base logarithm. Note that the support of ρ must be contained in the support of σ but for efficiency this is not checked.\n\nReference: Quantum relative entropy\n\n\n\n\n\nrelative_entropy([base=2,] p::AbstractVector, q::AbstractVector)\n\nComputes the relative entropy D(p||q) = Σᵢpᵢlog(pᵢ/qᵢ) between two non-negative vectors p and q using a base base logarithm. Note that the support of p must be contained in the support of q but for efficiency this is not checked.\n\nReference: Relative entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.binary_relative_entropy","page":"List of functions","title":"Ket.binary_relative_entropy","text":"binary_relative_entropy([base=2,] p::Real, q::Real)\n\nComputes the binary relative entropy D(p||q) = p log(p/q) + (1-p) log((1-p)/(1-q)) between two probabilities p and q using a base base logarithm.\n\nReference: Relative entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.conditional_entropy","page":"List of functions","title":"Ket.conditional_entropy","text":"conditional_entropy([base=2,] pAB::AbstractMatrix)\n\nComputes the conditional Shannon entropy H(A|B) of the joint probability distribution pAB using a base base logarithm.\n\nReference: Conditional entropy\n\n\n\n\n\nconditional_entropy([base=2,], rho::AbstractMatrix, csys::AbstractVecOrTuple, dims::AbstractVecOrTuple)\n\nComputes the conditional von Neumann entropy of rho with subsystem dimensions dims and conditioning systems csys, using a base base logarithm.\n\nReference: Conditional quantum entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Incompatibility","page":"List of functions","title":"Incompatibility","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"incompatibility_robustness","category":"page"},{"location":"api/#Ket.incompatibility_robustness","page":"List of functions","title":"Ket.incompatibility_robustness","text":"incompatibility_robustness(\n    A::Vector{Measurement{<:Number}};\n    noise::String = \"general\",\n    return_parent::Bool = false,\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nComputes the incompatibility robustness of the measurements in the vector A. Depending on the noise model chosen, the second argument can be \"depolarizing\" ({tr(Aₐ)I/d}ₐ, where d is the dimension of the system), \"random\" ({I/n}ₐ, where n is the number of outcomes), \"probabilistic\" ({pₐI}ₐ, where p is a probability distribution), \"jointly_measurable\", or \"general\" (default). Returns the parent POVM if return_parent = true.\n\nReferences:\n\nDesignolle, Farkas, Kaniewski, arXiv:1906.00448 (for the different noise models)\nGühne et al., arXiv:2112.06784 (Section III.B.2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurements","page":"List of functions","title":"Measurements","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"Measurement\nsic_povm\ntest_sic\ntest_povm\ndilate_povm\npovm\ntensor_to_povm\npovm_to_tensor\nmub\ntest_mub","category":"page"},{"location":"api/#Ket.Measurement","page":"List of functions","title":"Ket.Measurement","text":"Measurement{T}\n\nAlias for Vector{Hermitian{T,Matrix{T}}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Ket.sic_povm","page":"List of functions","title":"Ket.sic_povm","text":"sic_povm([T=ComplexF64,] d::Integer)\n\nConstructs a vector of d² vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension d. This construction is based on the Weyl-Heisenberg fiducial.\n\nReference: Appleby, Yadsan-Appleby, Zauner, arXiv:1209.1813\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.test_sic","page":"List of functions","title":"Ket.test_sic","text":"test_sic(vecs)\n\nChecks if vecs is a vector of d² vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.test_povm","page":"List of functions","title":"Ket.test_povm","text":"test_povm(A::Vector{<:AbstractMatrix{T}})\n\nChecks if the measurement defined by A is valid (hermitian, semi-definite positive, and normalized).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.dilate_povm","page":"List of functions","title":"Ket.dilate_povm","text":"dilate_povm(vecs::Vector{Vector{T}})\n\nDoes the Naimark dilation of a rank-1 POVM given as a vector of vectors. This is the minimal dilation.\n\n\n\n\n\ndilate_povm(E::Vector{<:AbstractMatrix})\n\nDoes the Naimark dilation of a POVM given as a vector of matrices. This always works, but is wasteful if the POVM elements are not full rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.povm","page":"List of functions","title":"Ket.povm","text":"povm(B::Vector{<:AbstractMatrix{T}})\n\nCreates a set of (projective) measurements from a set of bases given as unitary matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_to_povm","page":"List of functions","title":"Ket.tensor_to_povm","text":"tensor_to_povm(A::Array{T,4}, o::Vector{Int})\n\nConverts a set of measurements in the common tensor format into a matrix of (hermitian) matrices. By default, the second argument is fixed by the size of A. It can also contain custom number of outcomes if there are measurements with less outcomes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.povm_to_tensor","page":"List of functions","title":"Ket.povm_to_tensor","text":"povm_to_tensor(Axa::Vector{<:Measurement})\n\nConverts a matrix of (hermitian) matrices into a set of measurements in the common tensor format.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.mub","page":"List of functions","title":"Ket.mub","text":"mub([T=ComplexF64,] d::Integer)\n\nConstruction of the standard complete set of MUBs. The output contains 1+minᵢ pᵢ^rᵢ bases, where d = ∏ᵢ pᵢ^rᵢ.\n\nReference: Durt, Englert, Bengtsson, Życzkowski, arXiv:1004.3348\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.test_mub","page":"List of functions","title":"Ket.test_mub","text":"test_mub(B::Vector{Matrix{<:Number}})\n\nChecks if the input bases are mutually unbiased.\n\n\n\n\n\n","category":"function"},{"location":"api/#Nonlocality","page":"List of functions","title":"Nonlocality","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"chsh\ncglmp\nbraunsteincaves\ninn22\ngyni\nlocal_bound\ntsirelson_bound\nseesaw\ntensor_probability\ntensor_collinsgisin\ntensor_correlation\nnonlocality_robustness","category":"page"},{"location":"api/#Ket.chsh","page":"List of functions","title":"Ket.chsh","text":"chsh([T=Float64,] d::Integer = 2)\n\nCHSH-d nonlocal game in probability notation. If T is an integer type the game is unnormalized.\n\nReference: Buhrman and Massar, arXiv:quant-ph/0409066\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.cglmp","page":"List of functions","title":"Ket.cglmp","text":"cglmp([T=Float64,] d::Integer = 3)\n\nCGLMP nonlocal game in probability notation. If T is an integer type the game is unnormalized.\n\nReferences:\n\nCollins, Gisin, Linden, Massar, Popescu, arXiv:quant-ph/0106024 (original game)\nAraújo, Hirsch, Quintino, arXiv:2005.13418 (form presented here)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.braunsteincaves","page":"List of functions","title":"Ket.braunsteincaves","text":"braunsteincaves([T=Float64,] s::Integer = 3)\n\nBraunstein-Caves nonlocal game in probability notation. Known in the computer science literature as odd cycle game. If T is an integer type the game is unnormalized.\n\nReferences: Braunstein and Caves doi:10.1016/0003-4916(90)90339-P Cleve et al., arXiv:quant-ph/0404076\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.inn22","page":"List of functions","title":"Ket.inn22","text":"inn22([T=Float64,] n::Integer = 3)\n\ninn22 Bell functional in Collins-Gisin notation. Local bound 1.\n\nReference: Cezary Śliwa, arXiv:quant-ph/0305190\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.gyni","page":"List of functions","title":"Ket.gyni","text":"gyni([T=Float64,] n::Integer)\n\nGuess your neighbour's input nonlocal game in probability notation. If T is an integer type the game is unnormalized.\n\nReference: Almeida et al., arXiv:1003.3844\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.local_bound","page":"List of functions","title":"Ket.local_bound","text":"local_bound(G::Array{T,N}; correlation = N < 4, marg = true)\n\nComputes the local bound of a multipartite Bell functional G given as an N-dimensional array. If correlation is false, G is assumed to be written in probability notation. If correlation is true, G is assumed to be written in correlation notation, with or without marginals depending on marg.\n\nReference: Araújo, Hirsch, Quintino, arXiv:2005.13418\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tsirelson_bound","page":"List of functions","title":"Ket.tsirelson_bound","text":"tsirelson_bound(CG::Array, scenario::Tuple, level; verbose::Bool = false, dualize::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})\n\nUpper bounds the Tsirelson bound of a multipartite Bell funcional CG, written in Collins-Gisin notation. scenario is a tuple detailing the number of inputs and outputs, in the order (oa, ob, ..., ia, ib, ...). level is an integer or a string like \"1 + A B\" determining the level of the NPA hierarchy. verbose determines whether solver output is printed. dualize determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.\n\n\n\n\n\ntsirelson_bound(FC::Array, level; verbose::Bool = false, dualize::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})\n\nUpper bounds the Tsirelson bound of a multipartite Bell funcional FC, written in correlation notation. level is an integer or a string like \"1 + A B\" determining the level of the NPA hierarchy. verbose determines whether solver output is printed. dualize determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.seesaw","page":"List of functions","title":"Ket.seesaw","text":"seesaw(\n    CG::Matrix,\n    scenario::AbstractVecOrTuple,\n    d::Integer,\n    n_trials::Integer = 1;\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nMaximizes bipartite Bell functional in Collins-Gisin notation CG using the seesaw heuristic. scenario is a vector detailing the number of inputs and outputs, in the order [oa, ob, ia, ib]. d is an integer determining the local dimension of the strategy.\n\nIf oa = ob = 2 the heuristic reduces to a bunch of eigenvalue problems. Otherwise semidefinite programming is needed and we use the assemblage version of seesaw.\n\nThe heuristic is run n_trials times, and the best run is outputted.\n\nReferences:\n\nPál and Vértesi, arXiv:1006.3032\nTavakoli et al., arXiv:2307.02551 (Sec. II.B.1)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_probability","page":"List of functions","title":"Ket.tensor_probability","text":"tensor_probability(CG::Array, scenario::Tuple, behaviour::Bool = false)\n\nTakes a multipartite Bell functional CG in Collins-Gisin notation and transforms it to probability notation. scenario is a tuple detailing the number of inputs and outputs, in the order (oa, ob, ..., ia, ib, ...). If behaviour is true do instead the transformation for behaviours. Doesn't assume normalization.\n\n\n\n\n\ntensor_probability(FC::Matrix, behaviour::Bool = false)\n\nTakes a bipartite Bell functional FC in correlation notation and transforms it to probability notation. If behaviour is true do instead the transformation for behaviours. Doesn't assume normalization.\n\n\n\n\n\ntensor_probability(rho::Hermitian, all_Aax::Vector{Measurement}...)\ntensor_probability(rho::Hermitian, Aax::Vector{Measurement}, N::Integer)\n\nApplies N sets of measurements onto a state rho to form a probability array. If all parties apply the same measurements, use the shorthand notation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_collinsgisin","page":"List of functions","title":"Ket.tensor_collinsgisin","text":"tensor_collinsgisin(p::Array, behaviour::Bool = false)\n\nTakes a multipartite Bell functional p in probability notation and transforms it to Collins-Gisin notation. If behaviour is true do instead the transformation for behaviours. Doesn't assume normalization.\n\nAlso accepts the arguments of tensor_probability (state and measurements) for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_correlation","page":"List of functions","title":"Ket.tensor_correlation","text":"tensor_correlation(p::AbstractArray{T, N2}, behaviour::Bool = false; marg::Bool = true)\n\nConverts a 2 × … × 2 × m × … × m probability array into\n\nan m × … × m correlation array (no marginals)\nan (m+1) × … × (m+1) correlation array (marginals).\n\nIf behaviour is true do the transformation for behaviours. Doesn't assume normalization.\n\nAlso accepts the arguments of tensor_probability (state and measurements) for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.nonlocality_robustness","page":"List of functions","title":"Ket.nonlocality_robustness","text":"nonlocality_robustness(FP::Array; noise::String = \"white\", verbose::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})\n\nComputes the nonlocality robustness of the behaviour FP. Argument noise indicates the kind of noise to be used: \"white\" (default), \"local\", or \"general\".\n\nReference: Baek, Ryu, Lee, arxiv:2311.07077\n\n\n\n\n\n","category":"function"},{"location":"api/#Norms","page":"List of functions","title":"Norms","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"trace_norm\nkyfan_norm\nschatten_norm\ndiamond_norm","category":"page"},{"location":"api/#Ket.trace_norm","page":"List of functions","title":"Ket.trace_norm","text":"trace_norm(X::AbstractMatrix)\n\nComputes trace norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.kyfan_norm","page":"List of functions","title":"Ket.kyfan_norm","text":"kyfan_norm(X::AbstractMatrix, k::Integer, p::Real = 2)\n\nComputes Ky-Fan (k,p) norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.schatten_norm","page":"List of functions","title":"Ket.schatten_norm","text":"schatten_norm(X::AbstractMatrix, p::Real)\n\nComputes Schatten p-norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.diamond_norm","page":"List of functions","title":"Ket.diamond_norm","text":"diamond_norm(\n    J::AbstractMatrix,\n    dims::AbstractVecOrTuple;\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nComputes the diamond norm of the supermap J given in the Choi-Jamiołkowski representation, with subsystem dimensions dims.\n\nReference: Diamond norm\n\n\n\n\n\ndiamond_norm(K::Vector{<:AbstractMatrix})\n\nComputes the diamond norm of the CP map given by the Kraus operators K.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameterizations","page":"List of functions","title":"Parameterizations","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"parameterized_unitary","category":"page"},{"location":"api/#Ket.parameterized_unitary","page":"List of functions","title":"Ket.parameterized_unitary","text":"parameterized_unitary(λ::AbstractMatrix{T})\n\nProduces the unitary matrix parameterized by λ.\n\nReference: Spengler, Huber, Hiesmayr, arXiv:1004.5252\n\n\n\n\n\n","category":"function"},{"location":"api/#Random","page":"List of functions","title":"Random","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"random_state\nrandom_state_ket\nrandom_unitary\nrandom_isometry\nrandom_povm\nrandom_probability","category":"page"},{"location":"api/#Ket.random_state","page":"List of functions","title":"Ket.random_state","text":"random_state([T=ComplexF64,] d::Integer, k::Integer = d)\n\nProduces a uniformly distributed random quantum state in dimension d with rank k.\n\nReference: Życzkowski and Sommers, arXiv:quant-ph/0012101\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_state_ket","page":"List of functions","title":"Ket.random_state_ket","text":"random_state_ket([T=ComplexF64,] d::Integer)\n\nProduces a Haar-random quantum state vector in dimension d.\n\nReference: Życzkowski and Sommers, arXiv:quant-ph/0012101\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_unitary","page":"List of functions","title":"Ket.random_unitary","text":"random_unitary([T=ComplexF64,] d::Integer)\n\nProduces a Haar-random unitary matrix in dimension d. If T is a real type the output is instead a Haar-random (real) orthogonal matrix.\n\nReference: Gilbert W. Stewart, doi:10.1137/0717034\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_isometry","page":"List of functions","title":"Ket.random_isometry","text":"random_isometry([T=ComplexF64,] d::Integer, k::Integer)\n\nProduces a Haar-random isometry with d rows and k columns.\n\nReference: Gilbert W. Stewart, doi:10.1137/0717034\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_povm","page":"List of functions","title":"Ket.random_povm","text":"random_povm([T=ComplexF64,] d::Integer, n::Integer, k::Integer)\n\nProduces a random POVM of dimension d with n outcomes and rank min(k, d).\n\nReference: Heinosaari et al., arXiv:1902.04751\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_probability","page":"List of functions","title":"Ket.random_probability","text":"random_probability([T=Float64,] d::Integer)\n\nProduces a random probability vector of dimension d uniformly distributed on the simplex.\n\nReference: Dirichlet distribution\n\n\n\n\n\n","category":"function"},{"location":"api/#States","page":"List of functions","title":"States","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"state_bell_ket\nstate_bell\nstate_phiplus_ket\nstate_phiplus\nstate_psiminus_ket\nstate_psiminus\nstate_supersinglet_ket\nstate_supersinglet\nstate_ghz_ket\nstate_ghz\nstate_w_ket\nstate_w\nstate_dicke_ket\nstate_dicke\nstate_horodecki33\nstate_horodecki24\nstate_grid\nstate_crosshatch\nstate_symmetric_ket\nstate_symmetric\nstate_antisymmetric_ket\nstate_antisymmetric\nstate_sindici_piani_ket\nstate_sindici_piani\nwhite_noise\nwhite_noise!","category":"page"},{"location":"api/#Ket.state_bell_ket","page":"List of functions","title":"Ket.state_bell_ket","text":"state_bell_ket([T=ComplexF64,] a::Integer, b::Integer, d::Integer = 2)\n\nProduces the ket of the generalized Bell state ψ_ab of local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_bell","page":"List of functions","title":"Ket.state_bell","text":"state_bell([T=ComplexF64,] a::Integer, b::Integer, d::Integer = 2, v::Real = 1)\n\nProduces the generalized Bell state ψ_ab of local dimension d with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_phiplus_ket","page":"List of functions","title":"Ket.state_phiplus_ket","text":"state_phiplus_ket([T=ComplexF64,] d::Integer = 2)\n\nProduces the ket of the maximally entangled state ϕ⁺ of local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_phiplus","page":"List of functions","title":"Ket.state_phiplus","text":"state_phiplus([T=ComplexF64,] d::Integer = 2; v::Real = 1)\n\nProduces the maximally entangled state ϕ⁺ of local dimension d with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_psiminus_ket","page":"List of functions","title":"Ket.state_psiminus_ket","text":"state_psiminus_ket([T=ComplexF64,] d::Integer = 2)\n\nProduces the ket of the maximally entangled state ψ⁻ of local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_psiminus","page":"List of functions","title":"Ket.state_psiminus","text":"state_psiminus([T=ComplexF64,] d::Integer = 2; v::Real = 1)\n\nProduces the maximally entangled state ψ⁻ of local dimension d with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_supersinglet_ket","page":"List of functions","title":"Ket.state_supersinglet_ket","text":"state_supersinglet_ket([T=ComplexF64,] N::Integer = 3; coeff = 1/√N!)\n\nProduces the ket of the N-partite N-level singlet state.\n\nReference: Adán Cabello, arXiv:quant-ph/0203119\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_supersinglet","page":"List of functions","title":"Ket.state_supersinglet","text":"state_supersinglet([T=ComplexF64,] N::Integer = 3; v::Real = 1)\n\nProduces the N-partite N-level singlet state with visibility v. This state is invariant under simultaneous rotations on all parties: (U    U) ρ (U    U) = ρ.\n\nReference: Adán Cabello, arXiv:quant-ph/0203119\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_ghz_ket","page":"List of functions","title":"Ket.state_ghz_ket","text":"state_ghz_ket([T=ComplexF64,] d::Integer = 2, N::Integer = 3; coeff = 1/√d)\n\nProduces the ket of the GHZ state with N parties and local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_ghz","page":"List of functions","title":"Ket.state_ghz","text":"state_ghz([T=ComplexF64,] d::Integer = 2, N::Integer = 3; v::Real = 1, coeff = 1/√d)\n\nProduces the GHZ state with N parties, local dimension d, and visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_w_ket","page":"List of functions","title":"Ket.state_w_ket","text":"state_w_ket([T=ComplexF64,] N::Integer = 3; coeff = 1/√N)\n\nProduces the ket of the N-partite W state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_w","page":"List of functions","title":"Ket.state_w","text":"state_w([T=ComplexF64,] N::Integer = 3; v::Real = 1, coeff = 1/√N)\n\nProduces the N-partite W state with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_dicke_ket","page":"List of functions","title":"Ket.state_dicke_ket","text":"state_dicke_ket([T=ComplexF64,] k::Integer, N::Integer; coeff = 1/√Cᴺₖ)\n\nProduces the ket of the N-partite Dicke state with k excitations.\n\nReference: Robert H. Dicke doi:10.1103/PhysRev.93.99\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_dicke","page":"List of functions","title":"Ket.state_dicke","text":"state_dicke([T=ComplexF64,] k::Integer, N::Integer; v::Real = 1)\n\nProduces the N-partite Dicke state with k excitations.\n\nReference: Robert H. Dicke doi:10.1103/PhysRev.93.99\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_horodecki33","page":"List of functions","title":"Ket.state_horodecki33","text":"state_horodecki33([T=ComplexF64,] a::Real)\n\nProduces the 3 × 3 bipartite PPT-entangled Horodecki state with parameter a.\n\nReference: Paweł Horodecki, arXiv:quant-ph/9703004\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_horodecki24","page":"List of functions","title":"Ket.state_horodecki24","text":"state_horodecki24([T=ComplexF64,] b::Real)\n\nProduces the 2 × 4 bipartite PPT-entangled Horodecki state with parameter b.\n\nReference: Paweł Horodecki, arXiv:quant-ph/9703004\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_grid","page":"List of functions","title":"Ket.state_grid","text":"state_grid([T=ComplexF64], dA::Integer, dB::Integer, edges::Vector{Vector{ntuple{2, Int}}}; weights::Vector{T} = ones(T, length(edges)))\n\nProduces the bipartite dA × dB grid state according to the dA × dB 2D (hyper-)graph with edges and weights.\n\nReference:\n\nLockhart et al., arXiv:1705.09261\nGhimire et al., arXiv:2207.09826\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_crosshatch","page":"List of functions","title":"Ket.state_crosshatch","text":"state_crosshatch([T=ComplexF64])\n\nProduces a bound entangled bipartite 3 × 3 crosshatch state.\n\nReference: Lockhart et al., arXiv:1705.09261\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_symmetric_ket","page":"List of functions","title":"Ket.state_symmetric_ket","text":"state_symmetric_ket([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; coeff = 1/√2)\n\nProduces the ket of the eigenstate of symmetric space of local dimensions d × d, i.e., |ψ⁺ₖₗ⟩ = (|k⟩|l⟩ + |l⟩|k⟩) / √2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_symmetric","page":"List of functions","title":"Ket.state_symmetric","text":"state_symmetric([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; v::Real = 1)\n\nProduces the bipartite symmetric state ψ⁺ₖₗ of local dimensions d × d with visibility v, with  |ψ⁺ₖₗ⟩ = (|k⟩|l⟩ + |l⟩|k⟩) / √2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_antisymmetric_ket","page":"List of functions","title":"Ket.state_antisymmetric_ket","text":"state_antisymmetric_ket([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; coeff = 1/√2)\n\nProduces the ket of the eigenstate of antisymmetric space with local dimension d×d, i.e., |ψ⁻ₖₗ⟩ = (|k⟩|l⟩ - |l⟩|k⟩) / √2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_antisymmetric","page":"List of functions","title":"Ket.state_antisymmetric","text":"state_antisymmetric([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; v::Real = 1)\n\nProduces the bipartite antisymmetric state ψ⁻ₖₗ of local dimensions d × d with visibility v, with  |ψ⁻ₖₗ⟩ = (|k⟩|l⟩ - |l⟩|k⟩) / √2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_sindici_piani_ket","page":"List of functions","title":"Ket.state_sindici_piani_ket","text":"state_sindici_piani_ket([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; coeff = inv(_sqrt(T, 2)))\n\nProduces the ket of Sindici-Piani state of even local dimensions d × d\n\nReference: Sindici and Piani, arXiv:1708.06595\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_sindici_piani","page":"List of functions","title":"Ket.state_sindici_piani","text":"state_sindici_piani([T=ComplexF64], d::Integer; coeffs = [√2/√d, ⋯, √2/√d])\n\nProduces the Sindici-Piani state of even local dimensions d × d with visibility v.\n\nReference: Sindici and Piani, arXiv:1708.06595\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.white_noise","page":"List of functions","title":"Ket.white_noise","text":"white_noise(rho::AbstractMatrix, v::Real)\n\nReturns v * rho + (1 - v) * id, where id is the maximally mixed state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.white_noise!","page":"List of functions","title":"Ket.white_noise!","text":"white_noise!(rho::AbstractMatrix, v::Real)\n\nModifies rho in place to tranform it into v * rho + (1 - v) * id where id is the maximally mixed state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-functions","page":"List of functions","title":"Internal functions","text":"","category":"section"},{"location":"api/","page":"List of functions","title":"List of functions","text":"Ket._dps_constraints!\nKet._inner_dps_constraints!\nKet._partition\nKet._fiducial_WH","category":"page"},{"location":"api/#Ket._dps_constraints!","page":"List of functions","title":"Ket._dps_constraints!","text":"_dps_constraints!(model::JuMP.GenericModel, ρ::AbstractMatrix, dims::AbstractVecOrTuple, n::Integer; ppt::Bool = true, is_complex::Bool = true, isometry::AbstractMatrix = I(size(ρ, 1)))\n\nConstrains state ρ of dimensions dims in JuMP model model to respect the DPS constraints of level n. Dimensions are specified in dims = [dA, dB] and the extensions will be done on the second subsystem. The extensions can be symmetric real matrices (is_complex = false) or Hermitian PSD. With ppt = true, PPT constraints are enforced for transposed subsystems 2:i, for i ∈ 2:n+1. Use isometry to specify a V to be applied in the constraint ρ = V * tr_B_2  B_n(Ξ) V.\n\nReference: Doherty, Parrilo, Spedalieri, arXiv:quant-ph/0308032\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._inner_dps_constraints!","page":"List of functions","title":"Ket._inner_dps_constraints!","text":"_inner_dps_constraints!(model::JuMP.GenericModel, ρ::AbstractMatrix, dims::AbstractVecOrTuple, n::Integer; ppt::Bool = true, is_complex::Bool = true, isometry::AbstractMatrix = I(size(ρ, 1)))\n\nConstrains state ρ of dimensions dims in JuMP model model to respect the Inner DPS constraints of level n. Dimensions are specified in dims = [dA, dB] and the extensions will be done on the second subsystem. The extensions can be symmetric real matrices (is_complex = false) or Hermitian PSD. With ppt = true, the extended part is constrained to be PPT for the [1:⌈n/2⌉+1, rest] partition.\n\nReferences: Navascués, Owari, Plenio arXiv:0906.2735 and arXiv:0906.2731\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._partition","page":"List of functions","title":"Ket._partition","text":"partition(n::Integer, k::Integer)\n\nIf n ≥ k partitions the set 1:n into k parts as equally sized as possible. Otherwise partitions it into n parts of size 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._fiducial_WH","page":"List of functions","title":"Ket._fiducial_WH","text":"_fiducial_WH([T=ComplexF64,] d::Integer)\n\nComputes the fiducial Weyl-Heisenberg vector of dimension d.\n\nReferences:\n\nAppleby, Yadsan-Appleby, Zauner, arXiv:1209.1813\nwww.gerhardzauner.at/sicfiducials.html\n\n\n\n\n\n","category":"function"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"EditURL = \"getting_started.jl\"","category":"page"},{"location":"getting_started/#Julia","page":"Getting started","title":"Julia","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ket is a Julia package, and to use it Julia must be installed. You can do that by following the instructions for your operating system in the official Julia page.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Julia can be used in different ways:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"As a script interpreter, by running julia script.jl in the terminal, where script.jl is a file containing Julia code.\nAs a Jupyter notebook, which resembles the Mathematica interface, and where code blocks can be mixed with text and equations.\nAs a REPL (Read-Eval-Print Loop), which is a command-line interface where you can type Julia code and get immediate feedback, similar to MATLAB and the Python interpreter.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To access the REPL, you can run julia in the terminal. You will see the julia> prompt, and you can start coding right away (you can exit the REPL with exit() or pressing Ctrl+D).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you are new to Julia, we recommend you to check out some basic Julia tutorials such as this one before proceeding.","category":"page"},{"location":"getting_started/#Installing-Ket","page":"Getting started","title":"Installing Ket","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ket can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"] add Ket","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The ] key opens Julia's built-in package manager, and the add command installs the package. Any officially registered package can be installed in the same way.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Tip\nSince Ket is in fast development, you might want to install the latest version by running ] add Ket#master instead.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"After the installation is complete, you can check that Ket is working by running the following command in the REPL:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Ket\nket(1)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The using Ket command tells Julia to load the Ket package, and that make its functions available in the current session.","category":"page"},{"location":"getting_started/#Using-Ket","page":"Getting started","title":"Using Ket","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ket is a package for quantum information theory, and it provides a set of tools for working with quantum states, measurements, and channels. It is designed to be user-friendly and to provide a high-level interface for common tasks in quantum information theory.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The best way to learn how to use Ket is by using the list of functions as a reference. It is designed to be self-contained and to provide examples for each function. Inside the REPL, you can also type ? followed by the name of the function to get a brief description of its usage, or use the function @doc, for example:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"@doc schmidt_decomposition","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"print(@doc schmidt_decomposition) #hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Beginners can be daunted by the first line in the function definitions, such as above, but they are only specifying the possible input arguments in terms of the types of variables. Julia's type system is very powerful, but to use Ket you only need to know a few facts.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"First, each variable in a function's input has a name, and the :: symbol can be used to specify the type of the variable. In schmidt_number, the input ψ::AbstractVector can be any vector, while dims::AbstractVector{<:Integer} is a vector of integers.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Some other functions accept an optional argument to specify the return type. For example:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"@doc random_state","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"print(@doc random_state) #hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Here, the first argument [T=ComplexF64,] specifies that the return type of the function can be controlled by the user, and the default is ComplexF64. This can be used to control the precision of the computations, but it is not necessary to know about it to use the function: You can just ignore it, and a sensible default type will be used. Any argument followed by a = is optional, and the default value is specified after the = symbol (for example, d::Integer = 2 above).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Finally, some functions also have keyword arguments. They are specified after a ; in the function definition:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"@doc entanglement_robustness","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"print(@doc entanglement_robustness) #hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"These are not positional arguments such as the ones that come before the ;. Instead, they must be passed by their names. So, for example, entanglement_robustness(ρ; noise = \"separable\") is a valid call for any matrix ρ:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"λ, W = entanglement_robustness(state_ghz(2, 2); noise = \"separable\")\nλ #hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"W #hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"tip: Tip\nJulia's REPL has a tab-completion feature that can be used to explore the functions available in Ket. You can type Ket. and press Tab to see a list of functions, or start the name of a function (e.g., state_) and press Tab to see a list of available states.","category":"page"},{"location":"getting_started/#Further-resources","page":"Getting started","title":"Further resources","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To see a showcase of what can be done with Ket, you can check the examples provided in the documentation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Other than learning the basics of Julia, we also recommend you to check the JuMP tutorial to learn how to use Julia for optimization problems. This is one of the most popular uses of Julia, and it is very easy to use it with Ket to solve quantum information problems. Ket integrates well with JuMP, offering for example functions that add common constraints to user-defined optimization problems, such as Ket._dps_constraints! and Ket._inner_dps_constraints!.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Finally, if you have any questions or suggestions, you can reach out to us or open an issue in the Ket repository.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"EditURL = \"tilted_chsh.jl\"","category":"page"},{"location":"examples/tilted_chsh/#Tilted-CHSH-inequality","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"","category":"section"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"Given a Bell expression we often want to compute its local bound and the maximum quantum violation. In Ket this can easily be done using the functions local_bound, seesaw and tsirelson_bound.","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"We will use the tilted CHSH inequality as an example (see Acín et al.’s “Randomness versus nonlocality and entanglement”):","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"alpha langle A_0 rangle + langle A_0 B_0 rangle + langle A_0 B_1 rangle + langle A_1 B_0 rangle - langle A_1 B_1 rangle oversetCleqslant 2+alpha oversetQleqslant sqrt8+2alpha^2","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"In this expression, the C bound is the local bound (that is, achievable with classical systems), and the Q bound is the analytical solution for the maximum violation using quantum systems. (Of course, in general we do not know the quantum bounds for an arbitrary inequality, this example is so we can compare the results we will obtain via optimization.)","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"Let us first define the Bell expression in the full probability representation:","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"tip: Tip\nYou can convert between behavior representations using the functions tensor_probability, tensor_collinsgisin and tensor_correlation. They also accept a state and a set of measurements as inputs, returning the corresponding behavior.","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"function tilted_chsh(α)\n    # in correlation notation, the tilted CHSH is:\n    corr = [0  α  0;\n            0  1  1;\n            0  1 -1]\n    return tensor_probability(corr)\nend\nprintln() #hide","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"Computing the lower bound amounts to finding the maximum of the expression over all deterministic strategies. This can be done using the local_bound function, which can be called on any expression written in correlation or full probability format.","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"using Ket\n\n# we take 10 different values of α\nα = LinRange(0, 1, 10)\n# the `.` operator applies the function to each element of the vector\nlocal_bounds = local_bound.(tilted_chsh.(α))","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"For the quantum value, we can:","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"Obtain lower bounds (with a quantum realization in a given dimension) using the seesaw function,  whose inputs are an inequality in the Collins-Gisin representation, a vector specifying the scenario, and the dimension.  Since the seesaw algorithm can get trapped in local maxima, it is recommended to run it multiple times and select the best shot.  This is automated via the optional last argument n_shots.\nObtain upper bounds using the tsirelson_bound function, which is based on the NPA hierarchy.  It takes an inequality in the Collins-Gisin or full probability representation, a vector specifying the scenario  (the number of outcomes and inputs per party), and the level of the NPA hierarchy.","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"tilted_chsh_cg(α) = tensor_collinsgisin(tilted_chsh(α))\n\n# the first output of seesaw is the bound\nquantum_lbounds = [seesaw(tilted_chsh_cg(αi), (2, 2, 2, 2), 2, 100)[1] for αi in α]\n\nquantum_ubounds_l1 = [tsirelson_bound(tilted_chsh_cg(αi), (2, 2, 2, 2), 1)[1] for αi in α]\nquantum_ubounds_l2 = [tsirelson_bound(tilted_chsh_cg(αi), (2, 2, 2, 2), 2)[1] for αi in α]\nprintln() #hide","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"To visualize the bounds, we can plot the results and compare them to the analytical solutions:","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"using Plots\n\nxs = LinRange(0, 1, 100)\n\nplt = plot(xs, (x -> 2 + x).(xs), label = \"Local bound (analytical)\", linewidth = 2.5)\nscatter!(α, local_bounds, label = \"Local bound (numerical)\", markersize = 5, markershape = :circle)\n\nplot!(xs, (x -> sqrt(8 + 2x^2)).(xs), label = \"Quantum bound (analytical)\", linewidth = 2.5)\nscatter!(α, quantum_lbounds, label = \"Quantum bound (seesaw)\", markersize = 4, markershape = :square)\nscatter!(α, quantum_ubounds_l1, label = \"Quantum bound (NPA 1)\", markersize = 5, markershape = :diamond)\nscatter!(α, quantum_ubounds_l2, label = \"Quantum bound (NPA 2)\", markersize = 4, markershape = :utriangle)\nplot!(xlabel = \"α\", title = \"α⟨A₀⟩ + CHSH\")","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"","category":"page"},{"location":"examples/tilted_chsh/","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/dev-ket/Ket.jl/blob/master/README.md\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Banner)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ket is a toolbox for quantum information, nonlocality, and entanglement written in the Julia programming language. All its functions are designed to work with generic types, allowing one to use Int64 or Float64 for efficiency, or arbitrary precision types when needed. Wherever possible they can be also used for optimization with JuMP. And everything is optimized to the last microsecond.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Highlights:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Work with multipartite Bell inequalities, computing their local bounds and Tsirelson bounds with local_bound and tsirelson_bound, and transforming between Collins-Gisin, probability, and correlation representations with tensor_collinsgisin, tensor_probability, and tensor_correlation.\nWork with bipartite entanglement by computing the relative entropy of entanglement, entanglement robustness, or Schmidt number via entanglement_entropy, entanglement_robustness, and schmidt_number. Under the hood these functions use the DPS hierarchy, which is also available in isolation via _dps_constraints!.\nGenerate MUBs and SIC-POVMs through mub and sic_povm.\nGenerate uniformly-distributed random states, unitaries, and POVMs with random_state, random_unitary, and random_povm.\nGenerate well-known families of quantum states, such as the Bell states, the GHZ state, the W state, the Dicke states, and the super-singlet via state_bell, state_ghz, state_w, state_dicke, and state_supersinglet.\nWork with multilinear algebra via utility functions such as partial_trace, partial_transpose, and permute_systems.\nGenerate kets with ket.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the full list of functions see the documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ket is a registered Julia package, so it can be installed by typing the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add Ket","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the latest released version. For the development version with the latest updates, use ]add Ket#master instead.","category":"page"},{"location":"#Related-libraries","page":"Home","title":"Related libraries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"QuantumClifford.jl\nQuantumOptics.jl\nQuantumToolbox.jl\nYao.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Python:","category":"page"},{"location":"","page":"Home","title":"Home","text":"toqito","category":"page"},{"location":"","page":"Home","title":"Home","text":"MATLAB:","category":"page"},{"location":"","page":"Home","title":"Home","text":"QETLAB","category":"page"}]
}
